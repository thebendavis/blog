<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>TheBenDavis.net</title><link href="http://www.thebendavis.net/" rel="alternate"></link><link href="http://www.thebendavis.net/feeds/ben-davis.atom.xml" rel="self"></link><id>http://www.thebendavis.net/</id><updated>2015-02-06T20:00:00-08:00</updated><entry><title>DBTaint: Cross-Application Information Flow Tracking via Databases</title><link href="http://www.thebendavis.net/blog/dbtaint-database-information-flow-tracking-overview/" rel="alternate"></link><updated>2015-02-06T20:00:00-08:00</updated><author><name>Ben Davis</name></author><id>tag:www.thebendavis.net,2015-02-06:blog/dbtaint-database-information-flow-tracking-overview/</id><summary type="html">&lt;h3&gt;The dangers of user content&lt;/h3&gt;
&lt;p&gt;One major challenge modern web services face is how to safely incorporate user content.
Naive use of potentially malicious content can leave the service and its visitors vulnerable to attack.
Many of these attacks work by &lt;a href="https://en.wikipedia.org/wiki/Code_injection"&gt;code injection&lt;/a&gt;, in which improperly handled content is used in an unsafe way.
For example, in &lt;a href="https://en.wikipedia.org/wiki/Cross-site_scripting"&gt;cross-site scripting (XSS)&lt;/a&gt;, malicious content is injected into web pages served to users of the web service.
This can allow an attacker to bypass the same-origin policy, steal credentials of other users visiting the site, and much more.&lt;/p&gt;
&lt;p&gt;In order to prevent these types of attacks, the developers of a service must make sure that all untrusted (potentially malicious) content is sanitized before it is used in an unsafe way.
Unfortunately, any mistake could leave a gap that an attacker could use to exploit the service.
Trying to find and close all of these gaps, while avoiding the introduction of new ones, can seem like a game of &lt;a href="https://en.wikipedia.org/wiki/Whac-A-Mole#Colloquial_usage" title="whenever a problem is 'whacked,' another one pops up somewhere else"&gt;Whac-A-Mole&lt;/a&gt;, especially in systems originally developed without following industry best practices.&lt;/p&gt;
&lt;h3&gt;Tell me before I do something stupid!&lt;/h3&gt;
&lt;p&gt;Taking a step back, we see that the general problem is that when data is used in a dangerous operation the system has no way to know whether this data is safe to use or not.
It's up to the developers to make sure only safe (sanitized) data makes it this far - and to never make a mistake!
But there is another way to make sure only safe data is used in dangerous operations...&lt;/p&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Information_flow_%28information_theory%29" title="Information flow (information theory)"&gt;Information flow&lt;/a&gt; is a way to reason about how data flows through a system.
&lt;a href="http://en.wikipedia.org/wiki/Taint_checking"&gt;Taint checking&lt;/a&gt; can provide a dynamic system that approximates the verification from full information flow analysis.
In systems that provide taint checking, data from an untrusted source is marked as "tainted" in metadata associated with the data.
While more sophisticated schemes exist (and are supported by DBTaint), to simplify the discussion we will assume there is a single bit of metadata for each data value, indicating either "tainted" or "untainted."
Tainted data can only become untainted by passing through the appropriate sanitization routine.&lt;/p&gt;
&lt;p&gt;This metadata accompanies the data itself as it passes through the system, such as from one variable to another.
When data is passed to a potentially dangerous operation (e.g., &lt;code&gt;eval&lt;/code&gt;), this tracking system can inspect the metadata on the data to determine if the value is "tainted."
If so, then the system knows that this is (or at least could be) unsanitized data from an untrusted source and should not be allowed to be used in this dangerous operation.&lt;/p&gt;
&lt;p&gt;There are many dynamic information flow tracking systems that provide taint checking.
Perl and Ruby both include taint modes, and third-party systems exist for other languages, such as &lt;a href="http://www.eecs.berkeley.edu/~daw/papers/taint-sws09.pdf" title="Efficient Character-level Taint Tracking for Java"&gt;Java (PDF link)&lt;/a&gt; and &lt;a href="http://php.net/manual/en/book.taint.php"&gt;PHP&lt;/a&gt;.
This seems perfect for preventing cross-site scripting, SQL-injection, and many other attacks, so why isn't it widely used in web services?&lt;/p&gt;
&lt;h3&gt;Limitations of information flow tracking implementations&lt;/h3&gt;
&lt;p&gt;Unfortunately, most information flow tracking systems only work for a single application at a time.
For example, Perl's taint mode only maintains and propagates this taint metadata on data as it flows through the Perl program.
The problem is that most web services include not only a web application, but also a database.
All the metadata Perl's taint mode tracks is lost when sending data across the application boundaries into the database.
Similarly, when data is retrieved from the database Perl's taint mode has no idea how it should be marked.
The only two options Perl provides for this is to:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;treat everything from the database as tainted, or&lt;/li&gt;
&lt;li&gt;treat everything from the database as untainted&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Obviously, neither will provide satisfactory results for most web services.&lt;/p&gt;
&lt;p&gt;Other single-application information flow tracking systems have the same drawbacks.
And while system-wide information flow tracking systems exist, these generally lack the necessary granularity and support of database semantics to provide the precision necessary to protect against common web attacks.&lt;/p&gt;
&lt;p&gt;What can we do?&lt;/p&gt;
&lt;h3&gt;DBTaint enables cross-application information flow tracking via databases&lt;/h3&gt;
&lt;p&gt;At UC Davis, I led a project with the goal of empowering administrators of web services to use existing single-application information flow tracking systems in multi-application web services.
Since we enable taint checking from applications into databases, through database operations, and back into the application, we named this project &lt;strong&gt;DBTaint&lt;/strong&gt;.
DBTaint was designed and built to meet the following requirements:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;efficient end-to-end taint tracking through applications and databases&lt;/li&gt;
&lt;li&gt;full support of database operations and semantics&lt;/li&gt;
&lt;li&gt;deployment is transparent (requires no changes) to the web application&lt;/li&gt;
&lt;li&gt;requires only SQL-level changes on the database server (uses stock database engine)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Design and implementation&lt;/h3&gt;
&lt;p&gt;On initialization, DBTaint performs SQL-level changes to the database tables used by the app.
Additionally, DBTaint creates composite-type versions of all of the database data types.
These composite types include the data value as well as the associated metadata (i.e., taint value).
Also, it initializes and overloads the necessary database functions in order to perform taint-value propagation through database operations.
For example, it adds a &lt;code&gt;SUM&lt;/code&gt; function that produces an untainted result if and only if all of the values passed to it are untainted, otherwise it returns a result with the highest taint value of all of the input values.
Please see the publications listed below for details on the semantics of the database operations.&lt;/p&gt;
&lt;p&gt;This is a diagram showing a web service running in DBTaint.&lt;/p&gt;
&lt;p&gt;&lt;img alt="DBTaint System Diagram" src="http://www.thebendavis.net/blog_media/2015/dbtaint/dbtaint-system-diagram.png" title="&amp;quot;DBTaint System Diagram&amp;quot; =200x" /&gt;&lt;/p&gt;
&lt;p&gt;In the diagram above, the red rounded rectangle around the Web App indicates the single-application information flow tracking system (e.g., Perl's taint mode).
Observe that when a web app communicates with the database via a standard database interface module, this database interface is still running within the same single-application information flow tracking system.
The metadata associated with data intended for the database has not yet been lost.&lt;/p&gt;
&lt;p&gt;DBTaint provides end-to-end taint tracking transparently to the web application by augmenting the database interface to intercept and automatically rewrite database queries made by the web app.
When inserting data, the DBTaint-augmented version of the interface parses the query at run-time, and rewrites it to include the metadata associated with each data value before sending the rewritten query to the database.
This metadata is stored and propagated through the database using our composite types and functions.
Similarly, when querying for data, our augmented interface will collapse the resulting composite data/metadata pairs it gets from the database into appropriately tainted data values, which it returns to the web application.&lt;/p&gt;
&lt;p&gt;A major benefit of this approach is that the web app makes the same queries (and receives the same results) as running without DBTaint, so these changes are completely transparent to the web app.
The only difference from the web application's perspective is that the values it receives from the database are tainted appropriately (i.e., more precisely than the all-tainted or all-untainted options available without DBTaint).&lt;/p&gt;
&lt;p&gt;Once we have augmented a standard database interface, DBTaint supports any application that uses that standard interface.
In our current implementation we augment the &lt;a href="https://en.wikipedia.org/wiki/Java_Database_Connectivity"&gt;Java Database Connectivity (JDBC)&lt;/a&gt; interface used by Java programs, and the &lt;a href="https://en.wikipedia.org/wiki/Perl_DBI"&gt;Database Interface (DBI) module&lt;/a&gt; used by Perl programs.&lt;/p&gt;
&lt;p&gt;It is a best practice for application developers to use parameterized SQL queries, which makes it easy to determine the taint values of individual data values passed to the database as query parameters.
But when a web app creates queries by string concatenation, DBTaint parses the query string and uses character-level taint data (when available) to determine the most precise taint values of each data element in the query.&lt;/p&gt;
&lt;h3&gt;Using DBTaint for real-world services&lt;/h3&gt;
&lt;p&gt;Our implementation of DBTaint works with services implemented in Perl and Java that use PostgreSQL databases.
We use Perl's &lt;a href="http://perldoc.perl.org/perlsec.html#Taint-mode" title="perlsec: Taint Mode"&gt;taint mode&lt;/a&gt; (modified to act as a passive taint-tracking system) and &lt;a href="http://www.eecs.berkeley.edu/~daw/papers/taint-sws09.pdf" title="Efficient Character-level Taint Tracking for Java"&gt;this character-level taint tracking engine for Java (PDF link)&lt;/a&gt; to perform the appropriate information flow tracking when running two real-world web services in DBTaint:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.bestpractical.com/rt/" title="RT: Request Tracker"&gt;RT (Request Tracker)&lt;/a&gt;: a popular ticket-tracking system implemented in Perl&lt;/li&gt;
&lt;li&gt;&lt;a href="http://jforum.net/" title="jforum: a powerful and robust discussion board system implemented in Java"&gt;jforum&lt;/a&gt;: a powerful discussion board system implemented in Java&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note that these services were not written with DBTaint (or information flow tracking of any kind) in mind, and our approach did not require any code changes to either application.&lt;/p&gt;
&lt;p&gt;The performance impact of DBTaint on these systems was relatively low (less than 10-15% overhead) in our evaluation.
In additional experiments, we show that we can trade portability for performance by implementing the composite-type metadata propagation database functionality in C rather than in SQL to further reduce the overhead of our approach.
Please see our publications for a more detailed discussion of these topics.&lt;/p&gt;
&lt;h3&gt;Read more in our published work&lt;/h3&gt;
&lt;p&gt;Parts of this work have been published in the following peer-reviewed publication:&lt;/p&gt;
&lt;p&gt;&lt;span class="bib-entry"&gt;
    &lt;span class="papertitle"&gt;DBTaint: Cross-Application Information Flow Tracking via Databases (&lt;a href="/pubs/davis-webapps10-dbtaint.pdf"&gt;paper&lt;/a&gt;, &lt;a href="/pubs/davis-webapps10-dbtaint-slides.pdf"&gt;slides&lt;/a&gt;, &lt;a href="/pubs/davis-webapps10-dbtaint-poster.pdf"&gt;poster&lt;/a&gt;)&lt;/span&gt;
    &lt;span class="author"&gt;Benjamin Davis and Hao Chen.&lt;/span&gt;
    &lt;span class="venue"&gt;USENIX Conference on Web Applications (WebApps). Boston, MA, June 23-24, 2010.&lt;/span&gt;
  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;For further elaboration, please see my Ph.D. dissertation:&lt;/p&gt;
&lt;p&gt;&lt;span class="bib-entry"&gt;
    &lt;span class="papertitle"&gt;&lt;a href="/pubs/davis-dissertation.pdf"&gt;Protecting Systems from Within:&lt;br /&gt;Application-Level Observation and Control Mechanisms&lt;/a&gt;&lt;/span&gt;
    &lt;span class="author"&gt;Benjamin Davis, Department of Computer Science, University of California, Davis.&lt;/span&gt;
    &lt;span class="venue"&gt;Dissertation Committee: Hao Chen, Matthew Bishop, Karl Levitt&lt;/span&gt;
  &lt;/span&gt;&lt;/p&gt;</summary><category term="java"></category><category term="perl"></category><category term="sql"></category><category term="postgresql"></category><category term="web"></category></entry><entry><title>RetroSkeleton: Automatic Android App Bytecode Rewriting</title><link href="http://www.thebendavis.net/blog/retroskeleton-android-app-rewriting-overview/" rel="alternate"></link><updated>2015-01-30T20:00:00-08:00</updated><author><name>Ben Davis</name></author><id>tag:www.thebendavis.net,2015-01-30:blog/retroskeleton-android-app-rewriting-overview/</id><summary type="html">&lt;h3&gt;Do you know what your apps are doing?&lt;/h3&gt;
&lt;p&gt;Android is the &lt;a href="https://developer.android.com/about/index.html"&gt;most popular mobile platform in the world&lt;/a&gt;, and a major reason for this success is the tremendous number of third-party apps available for these devices.
But as amazing as it is to pack these little computers with sensors, fill them with our data, and keep them with us wherever we go, we should consider the risks we take when we run third-party software.
How can we understand and control what third-party apps are doing on our devices?&lt;/p&gt;
&lt;p&gt;Most Android apps never undergo a rigorous manual review and the controls provided by the Android platform (primarily the permission system) are quite limited.
Android's permission system requires app developers to declare all permissions (which you can think of as categories of functionality) their app may use.
In order to install an app, the user must grant unlimited access to all permissions requested by the app.
Many important permissions lack granularity.
For example, the &lt;code&gt;INTERNET&lt;/code&gt; permission enables unlimited connections to any host.
Once the app is installed, the user cannot change, restrict, or revoke the app's ability to perform most sensitive operations.&lt;/p&gt;
&lt;p&gt;These are not hypothetical concerns.
For example, when you install an app, Android does not allow you to
prevent a flashlight app from &lt;a href="http://www.ftc.gov/news-events/press-releases/2013/12/android-flashlight-app-developer-settles-ftc-charges-it-deceived" title="Android Flashlight App Developer Settles FTC Charges It Deceived Consumers: 'Brightest Flashlight' App Shared Users' Location, Device ID Without Consumers' Knowledge"&gt;uploading your personal data and location&lt;/a&gt;,
force &lt;a href="http://android-ssl.org/files/p50-fahl.pdf" title="Why Eve and Mallory Love Android: An Analysis of Android SSL (In)Security"&gt;apps that make insecure HTTP requests&lt;/a&gt; to use (encrypted) HTTPS connections instead,
or apply &lt;a href="http://android-developers.blogspot.ie/2013/08/some-securerandom-thoughts.html" title="Android Developers Blog: Some SecureRandom Thoughts"&gt;workarounds&lt;/a&gt;
to &lt;a href="http://www.symantec.com/connect/blogs/android-cryptographic-issue-may-affect-hundreds-thousands-apps" title="Android Cryptographic Issue May Affect Hundreds of Thousands of Apps"&gt;platform weaknesses&lt;/a&gt;
that leave &lt;a href="https://bitcoin.org/en/alert/2013-08-11-android" title="Android Security Vulnerability"&gt;unpatched bitcoin wallet apps vulnerable&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;RetroSkeleton gives users control over their apps&lt;/h3&gt;
&lt;p&gt;At the University of California, Davis, I led a project where my colleagues and I set out to develop a practical way to give users insight into and control over the third-party apps on their Android devices.
We developed RetroSkeleton: an Android app analysis and bytecode rewriting framework for altering the behavior of existing applications without requiring source code or app-specific guidance.
RetroSkeleton rewrites an app to produce a new app that obeys the desired policy.
The foundation of our system is a sophisticated static analysis engine that determines the modifications needed in order to enforce the desired behavior in an app automatically.
We named this app rewriting system RetroSkeleton after the ability to retrofit apps with new behavior by modifying their internals.&lt;/p&gt;
&lt;p&gt;We designed our system to be:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Complete:&lt;/strong&gt; able to intercept all invocations of behavior of interest, including those invoked dynamically (e.g., via reflection)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Flexible:&lt;/strong&gt; powerful enough to satisfy a wide range of security and functionality goals&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;App-Independent:&lt;/strong&gt; no manual app-specific guidance needed to create or apply these transformation policies&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Deployable:&lt;/strong&gt; rewritten apps work on unrooted, unmodified, stock Android devices with no additional software required&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;How does it work?&lt;/h3&gt;
&lt;p&gt;RetroSkeleton allows policy writers to create a single, high-level, app-agnostic policy that RetroSkeleton can apply to any Android app without requiring any manual guidance.
Our system takes as input an app-agnostic policy and applies it to an app automatically by identifying all the necessary transformations and generating all code needed for handlers/dispatch and interposition.
RetroSkeleton parses and rewrites &lt;a href="https://source.android.com/devices/tech/dalvik/dex-format.html" title="Dalvik Executable format"&gt;Android (dex) bytecode&lt;/a&gt; directly (i.e., rather than converting to Java bytecode), replacing all invocations of methods of interest with calls to new handlers with custom behavior, as determined by a policy specification.
Analysis and rewriting is done statically, but generates and inserts handlers that can make policy decisions within the rewritten app at run-time to deal with reflection and other dynamic behavior.
Rewritten apps can run on stock Android devices (no rooting/custom ROMs required).&lt;/p&gt;
&lt;p&gt;&lt;img alt="RetroSkeleton System Diagram" src="http://www.thebendavis.net/blog_media/2015/retroskeleton/retroskeleton-system-diagram.svg" title="RetroSkeleton System Diagram" /&gt;&lt;/p&gt;
&lt;p&gt;Users may apply RetroSkeleton to apps they download on their own, either directly or via online service, and corporate environments could require that apps be rewritten before installation on company devices (either on-demand or by providing a private market of rewritten apps).
Because RetroSkeleton policy specifications are app-agnostic, a small set of community-maintained and vetted policies could be used by a wide range of users.&lt;/p&gt;
&lt;p&gt;The majority of RetroSkeleton is implemented in &lt;a href="http://clojure.org/"&gt;Clojure&lt;/a&gt; and Java, with earlier work implemented in Python.
Please see our publications for details on the design and implementation of our system, as well as the interface policy writers use for policy specification.&lt;/p&gt;
&lt;h3&gt;Using RetroSkeleton on real apps&lt;/h3&gt;
&lt;p&gt;We created a number of policies to showcase the power and flexibility of RetroSkeleton.
Here are some of the behaviors our policies can automatically embed and enforce in Android apps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;prevent connections to unauthorized hosts via fine-grained network access controls (including user-configurable white/blacklists)&lt;/li&gt;
&lt;li&gt;dynamically replace apps' insecure HTTP requests (a &lt;a href="http://android-ssl.org/files/p50-fahl.pdf" title="Why Eve and Mallory Love Android: An Analysis of Android SSL (In)Security"&gt;common problem&lt;/a&gt;) with encrypted HTTPS requests when available (a la the &lt;a href="https://www.eff.org/https-everywhere" title="HTTPS-Everywhere browser extensions"&gt;HTTPS-Everywhere&lt;/a&gt; extensions for browsers)&lt;/li&gt;
&lt;li&gt;perform (rudimentary) app localization by translating app UI text dynamically via online translation services (think "translate this page" for app UI content)&lt;/li&gt;
&lt;li&gt;automatically patch apps with &lt;a href="http://android-developers.blogspot.ie/2013/08/some-securerandom-thoughts.html" title="Android Developers Blog: Some SecureRandom Thoughts"&gt;workarounds&lt;/a&gt; for &lt;a href="http://www.symantec.com/connect/blogs/android-cryptographic-issue-may-affect-hundreds-thousands-apps" title="Android Cryptographic Issue May Affect Hundreds of Thousands of Apps"&gt;known cryptographic vulnerabilities&lt;/a&gt; in older versions of the Android platform&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We applied each of these policies to over 1,000 top free apps from &lt;a href="https://play.google.com/store"&gt;Google Play&lt;/a&gt; and built an automated test system to run and exercise each rewritten app in an Android emulator to confirm the functionality of the rewritten apps, including the enforcement of the desired behavior.
Nearly all (more than 97.5%) successfully ran after rewriting (a few threw errors as a result of poorly handling changes in behavior, such as expecting a hardcoded string but receiving the translated version of that string).
For more details, please see our publications below.&lt;/p&gt;
&lt;p&gt;For most policies, the impact of the rewriting process on the size and run-time performance of the app is minimal.
On average, rewritten apps increased in size by only a few KiB, which was a less than 0.13% increase in overall app size in our data set.
The specific run-time performance impact depends on the new behavior added, but the inherent overhead of our approach is low, adding only fractions of a microsecond when interposing on method calls of interest (even on aging hardware).
Because much of the work is done statically, generally the impact is not much more than if the developer had originally written the app with the additional behavior.
The static analysis and app rewriting process itself is efficient in terms of time and computation required, averaging about 5 seconds to rewrite an app using normal desktop PC hardware.&lt;/p&gt;
&lt;h3&gt;Read more in our publications&lt;/h3&gt;
&lt;p&gt;Parts of this work have been published in the following peer-reviewed publications with the coauthors named below:&lt;/p&gt;
&lt;p&gt;&lt;span class="bib-entry"&gt;
    &lt;span class="papertitle"&gt;RetroSkeleton: Retrofitting Android Apps (&lt;a href="/pubs/davis-mobisys13-retroskeleton.pdf"&gt;paper&lt;/a&gt;, &lt;a href="/pubs/davis-mobisys13-retroskeleton-slides.pdf"&gt;slides&lt;/a&gt;)&lt;/span&gt;
    &lt;span class="author"&gt;Benjamin Davis and Hao Chen.&lt;/span&gt;
    &lt;span class="venue"&gt;11th International Conference on Mobile Systems, Applications and Services (MobiSys). Taipei, Taiwan, June 25-28, 2013.&lt;/span&gt;
  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="bib-entry"&gt;
    &lt;span class="papertitle"&gt;I-ARM-Droid: A Rewriting Framework for In-App Reference Monitors for Android Applications (&lt;a href="/pubs/davis-most12-iarm.pdf"&gt;paper&lt;/a&gt;, &lt;a href="/pubs/davis-most12-iarm-slides.pdf"&gt;slides&lt;/a&gt;)&lt;/span&gt;
    &lt;span class="author"&gt;Benjamin Davis, Ben Sanders, Armen Khodaverdian, and Hao Chen.&lt;/span&gt;
    &lt;span class="venue"&gt;IEEE Mobile Security Technologies (MoST). San Francisco, CA, May 24, 2012.&lt;/span&gt;
  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;For further elaboration, please see my Ph.D. dissertation:&lt;/p&gt;
&lt;p&gt;&lt;span class="bib-entry"&gt;
    &lt;span class="papertitle"&gt;&lt;a href="/pubs/davis-dissertation.pdf"&gt;Protecting Systems from Within:&lt;br /&gt;Application-Level Observation and Control Mechanisms&lt;/a&gt;&lt;/span&gt;
    &lt;span class="author"&gt;Benjamin Davis, Department of Computer Science, University of California, Davis.&lt;/span&gt;
    &lt;span class="venue"&gt;Dissertation Committee: Hao Chen, Matthew Bishop, Karl Levitt&lt;/span&gt;
  &lt;/span&gt;&lt;/p&gt;</summary><category term="android"></category><category term="dalvik"></category><category term="mobile"></category></entry></feed>