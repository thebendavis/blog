<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>TheBenDavis.net</title><link href="http://www.thebendavis.net/" rel="alternate"></link><link href="http://www.thebendavis.net/feeds/all.atom.xml" rel="self"></link><id>http://www.thebendavis.net/</id><updated>2015-02-27T20:00:00-05:00</updated><entry><title>Deft note-taking: the power of plain text</title><link href="http://www.thebendavis.net/blog/plain-text-note-taking-with-deft/" rel="alternate"></link><published>2015-02-27T20:00:00-05:00</published><author><name>Ben Davis</name></author><id>tag:www.thebendavis.net,2015-02-27:blog/plain-text-note-taking-with-deft/</id><summary type="html">&lt;h3&gt;A filing cabinet of post-it notes&lt;/h3&gt;
&lt;p&gt;I keep tons of little notes - information that I may not use frequently, isn't part of a bigger project, but might be useful later.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;"cheat sheets" for infrequently-used software and tools&lt;/li&gt;
&lt;li&gt;the steps I took to perform a complex configuration/setup task, and resolutions to cryptic errors that were difficult to diagnose&lt;/li&gt;
&lt;li&gt;notes from books I've read&lt;/li&gt;
&lt;li&gt;notes from workshops, presentations, and meetings not associated with a bigger project&lt;/li&gt;
&lt;li&gt;lots of lists: gift ideas for friends and family, my travel/packing list, organizations I need to contact with my updated address when I move, and many more&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;When in doubt, I'll save it in a note.
This has saved me dozens of times:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Weird workaround when setting up the server? Guess who saves the day (hours, at least) 18 months later when we get a new server and need to set it up the same way.&lt;/li&gt;
&lt;li&gt;"Wasn't there a guest speaker last year who talked about something like this?" Indeed there was - here are my notes about her presentation.&lt;/li&gt;
&lt;li&gt;"I think we looked into this but decided it was a dead end. Do you remember why?" Here are the technical limitations we hit.&lt;/li&gt;
&lt;li&gt;"Wait, what did we get him for last Christmas?" I have the list right here.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I use a system based on &lt;a href="http://daringfireball.net/projects/markdown/"&gt;markdown&lt;/a&gt;-formatted plain text files, accessed using &lt;a href="http://jblevins.org/projects/deft/"&gt;Deft&lt;/a&gt; for Emacs, and synced via Dropbox.
It's served me well for years, particularly in grad school when I was constantly exploring new ideas and performing experiments.
Here's a little about the why and how.&lt;/p&gt;
&lt;h3&gt;Sustainable note-taking&lt;/h3&gt;
&lt;p&gt;Ever spend an afternoon trying out some new software with a bunch of fancy knobs to turn, only to find it's not worth the hassle?
I wanted a note-taking system that is not only useful, but one I actually use enough to be worth the effort of maintaining.
If I have something to save, I want one trusted place to put it - and if I want to find something, I want one trusted place to look.&lt;/p&gt;
&lt;p&gt;Here are my requirements for a note-taking system:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Notes should be &lt;strong&gt;easy to write&lt;/strong&gt;. If adding or editing a note is slow, cumbersome, or requires many decisions, I'm less likely to do it.&lt;/li&gt;
&lt;li&gt;Notes should be &lt;strong&gt;easy to read&lt;/strong&gt;. Notes should be fast and simple to access, ideally across platforms. Furthermore, my data should be easy to export and migrate. Services will close and software will rot, and I don't want to lose my notes when this happens.&lt;/li&gt;
&lt;li&gt;Notes should be &lt;strong&gt;easy to find&lt;/strong&gt;. I need a good search system - fast and complete.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I explored a number of options: proprietary and open-source applications, online services, personal wikis...
During these experiments, I came up with a few additional requirements:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Easy to back up and restore individual notes&lt;/li&gt;
&lt;li&gt;Resilient to changes in note-taking software and variances in implementations (especially across platforms)&lt;/li&gt;
&lt;li&gt;Ability to access and edit notes while offline&lt;/li&gt;
&lt;li&gt;Easy to keep in sync across devices - the less I have to think about this, the better. Merge conflicts are a bummer, but out-of-sync binary blobs are worse.&lt;/li&gt;
&lt;li&gt;Not too "fiddly" - I found tagging/categorizing/cross-referencing notes was a time-sponge and rarely worth the effort. I'd just end up searching anyway.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;The power of plain text&lt;/h3&gt;
&lt;p&gt;Ultimately I settled on plain text files, one file per note, all in a single directory, with the title of the note as the file name.
This meets my requirements pretty well:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Text files are fast and easy to create and edit in just about any editor.&lt;/li&gt;
&lt;li&gt;Search is DIY but straightforward. Even &lt;code&gt;grep&lt;/code&gt; can be used in a pinch, and at least &lt;code&gt;grep&lt;/code&gt; is fast, reliable, and complete.&lt;/li&gt;
&lt;li&gt;Backups are straightforward, and it'd be hard to be more resilient to software changes.&lt;/li&gt;
&lt;li&gt;I keep my notes folder in Dropbox (I keep sensitive data elsewhere), and sync has worked well for me.&lt;/li&gt;
&lt;li&gt;Dropbox leaves files on the hard drive, so notes are available offline and are included in my system backups.&lt;/li&gt;
&lt;li&gt;Since I'm not dependent on Dropbox for anything other than pushing my data around, the day it stops working I can replace it with something else. I used &lt;a href="http://www.cis.upenn.edu/~bcpierce/unison/"&gt;Unison&lt;/a&gt; before Dropbox.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the content of the note files, I write in &lt;a href="http://daringfireball.net/projects/markdown/"&gt;markdown&lt;/a&gt;, which is a lightweight plain text format that is designed to be easy to read and write.
Markdown files are plain text and look like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# Simple syntax

Headings start with the # character.
Unordered lists look like this:

* alpha
* bravo
* charlie

# Links

Links can use [inline](http://example.com)
or [reference style][xyz] syntax.

[xyz]: http://example.net
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Markdown was originally designed for writing content that gets exported to HTML, but I rarely export my notes.
For me, following the markdown syntax just gives me a uniform format that is simple to write and easy to skim.
I also use markdown in other settings (like writing these blog posts), so it's familiar.
I keep &lt;a href="http://fletcherpenney.net/multimarkdown/"&gt;multimarkdown&lt;/a&gt; installed on my workstations for other purposes, so it is available on the occasion that I want to export a note to HTML, PDF, or RTF.&lt;/p&gt;
&lt;p&gt;There are a few downsides with plain text notes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;No attachments or fancy metadata. In practice, this hasn't been a big problem for me. By the time I'm creating substantial artifacts for a project, I've probably already set up a git repo or &lt;a href="https://trello.com/"&gt;Trello&lt;/a&gt; board or something for the project.&lt;/li&gt;
&lt;li&gt;Typesetting math isn't very elegant. You can write equations as LaTeX or something, but it's not ideal.&lt;/li&gt;
&lt;li&gt;No built-in sharing. You can mix-and-match whatever works for you (git repo, shared directory/drive, etc.) but you have to do it yourself.&lt;/li&gt;
&lt;li&gt;No built-in security mechanisms (e.g., encryption). If you don't trust Dropbox with your notes, you'll have to do something else to sync, like keeping files in an encrypted volume or on a USB stick you can keep with you.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Wrangling plain text files...&lt;/h3&gt;
&lt;p&gt;The great thing about plain text is you don't need anything special to read or write.
However, you can make it easier to do common things.&lt;/p&gt;
&lt;p&gt;I'm a big fan of the search-first design I first saw in a Mac app called &lt;a href="http://notational.net/"&gt;Notational Velocity&lt;/a&gt;.
The top two bullet points on the app description page are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;"&lt;strong&gt;Modeless Operation&lt;/strong&gt;: Searching for notes is not a separate action; rather, it is the primary interface."&lt;/li&gt;
&lt;li&gt;"&lt;strong&gt;Incremental Search&lt;/strong&gt;: Searching encompasses all notes' content and occurs instantly with each key pressed."&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I'm a big fan of this approach - just open and the app searches your notes incrementally as you type.
Sorting notes by most-recently-edited makes frequently-used notes even easier to find.&lt;/p&gt;
&lt;h4&gt;... on a workstation&lt;/h4&gt;
&lt;p&gt;I like Notational Velocity (and &lt;a href="http://brettterpstra.com/projects/nvalt/"&gt;nvALT&lt;/a&gt;, a popular fork), but I'm not always on a Mac so I need something I can use across all of my machines (Linux/Mac/Windows).&lt;/p&gt;
&lt;p&gt;Vim is great and use it regularly, but Emacs has become my go-to editor for most things (mostly because I'd rather write elisp than vimscript).
Since I use Emacs everywhere (including the terminal and over SSH), I looked at a number of Emacs-based options.
My favorite is &lt;a href="http://jblevins.org/projects/deft/"&gt;Deft&lt;/a&gt;: a brilliant Emacs mode inspired by Notational Velocity, featuring the same search-first design.
I use the &lt;a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Server.html"&gt;Emacs Server&lt;/a&gt; to keep Emacs running, so launching a new &lt;code&gt;emacsclient&lt;/code&gt; is very fast, and my notes are just a single keystroke away.
I enable &lt;code&gt;markdown-mode&lt;/code&gt; for my deft notes, and a few other settings, in &lt;a href="https://github.com/thebendavis/.emacs.d"&gt;my .emacs.d config on github&lt;/a&gt;.&lt;/p&gt;
&lt;h5&gt;A side note:&lt;/h5&gt;
&lt;p&gt;If you've already invested in Emacs, definitely check out &lt;a href="http://orgmode.org/"&gt;org mode&lt;/a&gt;, which has many more powerful features built on a plain-text system.
It goes way beyond markdown's features, including support for time tracking, task and project planning, scheduling, text-based spreadsheets (?!) and more.
Org mode works best when you can put everything into that system, which wasn't a good fit for my setting, but it's worth checking out to see if it works for you.&lt;/p&gt;
&lt;h4&gt;... on iOS&lt;/h4&gt;
&lt;p&gt;While I do most of my work on a desktop/laptop, it is useful to be able to quickly search and edit notes on a mobile device.
There are many mobile note-taking apps that sync with markdown files in a Dropbox folder.
On iOS, I've been using &lt;a href="http://bywordapp.com/ios"&gt;Byword&lt;/a&gt;, which has markdown support and the same incremental search features.&lt;/p&gt;
&lt;h3&gt;Keep it simple&lt;/h3&gt;
&lt;p&gt;I can't tell you how many times I've saved hours of work and frustration by finding a note I wrote years earlier.
But it would have never been there if I didn't have a near-frictionless way to add, search, and maintain my notes.
Simplicity is a feature that led me to an approach that's a bit DIY, but flexible and within my own control.
Out of all of the note-taking apps and services available five years ago, not every option would have left me with an upgrade path of "continue to use whatever text editor you like" to get me to today.
Find a system that works for you, but if you're trying to decide, it's worth thinking five years ahead before signing up for the latest (ad-supported?) note-taking-in-the-cloud service...&lt;/p&gt;</summary><category term="emacs"></category><category term="markdown"></category><category term="dropbox"></category><category term="ios"></category></entry><entry><title>Privacy-Preserving Alibis for Mobile Device Users</title><link href="http://www.thebendavis.net/blog/privacy-preserving-alibi-systems-overview/" rel="alternate"></link><published>2015-02-15T20:00:00-05:00</published><author><name>Ben Davis</name></author><id>tag:www.thebendavis.net,2015-02-15:blog/privacy-preserving-alibi-systems-overview/</id><summary type="html">&lt;h3&gt;Can you prove what you did last summer?&lt;/h3&gt;
&lt;p&gt;A man faced the death penalty when he was charged with the murder of a government witness.
Months after his arrest, the defense obtained the public transit records associated with the man's MetroCard and found that these records supported his claim that he was miles away at the time of the crime.
After seeing this new evidence, the prosecution &lt;a href="http://www.nytimes.com/2009/01/01/nyregion/01murder.html" title="Murder Case Dropped After MetroCard Verifies Alibi"&gt;dropped all charges&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Just imagine what might have happened if this man hadn't used his MetroCard that night.
Cases like this show that while it doesn't happen often, it can be incredibly important to have an alibi.
The tricky part is that you generally won't know when you'll need one before it's too late to get one - if you don't have one already, you're out of luck.
What can we do to make sure we have an alibi whenever we need one?&lt;/p&gt;
&lt;h3&gt;Travel like no one is watching&lt;/h3&gt;
&lt;p&gt;Inspired by the &lt;a href="https://en.wikipedia.org/wiki/Alibi"&gt;alibi defense&lt;/a&gt; in criminal procedures, here I'll be using the word "alibi" refer to the general notion of providing evidence to support a claim of having been at a particular place at a particular time.&lt;/p&gt;
&lt;p&gt;We can't always count on having used our MetroCard at a critical time.
We should proactively establish alibis whenever possible in order to maximize our chances of having an alibi when we need one - ideally without requiring too much thought or impact on our daily behavior.&lt;/p&gt;
&lt;p&gt;With the rise of modern smart phones, it is increasingly common to carry a mobile device with GPS and other location-based sensors wherever we go.
It seems like we should be able to use our mobile phones to establish "alibi" evidence for ourselves in the same way a MetroCard can serve this purpose.&lt;/p&gt;
&lt;p&gt;Indeed, there are many apps and services that track the location of mobile devices by having the device periodically upload its location to a centralized server.
The biggest problem with this approach is the lack of control the user has over their privacy - they must trust the third-party service completely with their personal location data.&lt;/p&gt;
&lt;p&gt;Furthermore, if users want to avoid revealing their location to the service when doing something they wish to keep private they must decide to turn off the service ahead of time.
This requires making manual decisions with potentially serious privacy implications, and once these decisions are made there is no going back.
Imagine an employee turning off their tracking service when taking a long lunch, later accused of robbing a bank at that time - they're out of luck!&lt;/p&gt;
&lt;p&gt;Is there a way to have the best of both worlds?
We'd like to make sure we always have an alibi when we need it, without relying on a third-party to track us and hope they don't do anything creepy - or that nobody creepy gets access to the third-party service's data!&lt;/p&gt;
&lt;h3&gt;Privacy-Preserving Alibi Systems&lt;/h3&gt;
&lt;p&gt;At UC Davis, I led a project with the goal of developing a way for mobile device users to make sure they have alibis when they need one in a way that doesn't require them to give up their privacy.
Our insight was that while you must reveal your identity when you &lt;em&gt;claim&lt;/em&gt; an alibi, we can construct a scheme where &lt;em&gt;creating&lt;/em&gt; the alibi does not reveal your identity.&lt;/p&gt;
&lt;p&gt;In our system, a user's mobile device runs an app that automatically participates in opportunistic exchanges with nearby devices, creating alibis for the &lt;strong&gt;alibi owner&lt;/strong&gt; in a way that does not reveal the identity of the alibi owner.
Essentially, this establishes a "testimony" that the other participant (the &lt;strong&gt;alibi corroborator&lt;/strong&gt;) observed the alibi owner (really, their mobile device and a computation requiring the owner's private key) at their current, shared location and time.
The alibi owner stores this testimony for later.&lt;/p&gt;
&lt;p&gt;If and only if the alibi owner wishes to claim that particular alibi, they can provide the testimony and some additional information to a &lt;strong&gt;judge&lt;/strong&gt; who can verify that the identity associated with the testimony does indeed match the alibi owner (and a number of other properties needed to detect various types of fraud and perjury).
This reveals no other information about any other alibis created by that user, so the user can disclose only what they want, and exactly what they want.
We require no trusted third party to create alibis or provide the security guarantees, and there is no third party that can force a reveal of the identity of alibis without the owner's participation.&lt;/p&gt;
&lt;p&gt;Specifically, we created two cryptographic schemes that allow a user's mobile device to opportunistically and automatically establish evidence to support claims of past locations ("alibis") on the user's behalf without revealing the user's identity.
These schemes bind the user's identity to an alibi when the alibi is created, but the identity is only revealed if and when the owner claims the alibi, leaving the user in complete control of the disclosure of their identity.
Our constructions are based on a string commitment scheme that is secure in the unbound receiver model.
These schemes are designed to work within the existing infrastructure available to mobile device users, and do not require additional or existing trusted third parties to fulfill the privacy guarantees of our schemes.&lt;/p&gt;
&lt;h3&gt;Design, implementation, and real-world feasibility&lt;/h3&gt;
&lt;p&gt;Please see the slides from my ASIACCS 2012 presentation for the general flow of the protocols, and the publications for details on the design and implementation of our cryptographic schemes.&lt;/p&gt;
&lt;p&gt;We have implemented the computational components of our schemes in an Android app that demonstrates that our approach is feasible for use on mobile devices, in terms of both computation and storage requirements.
The computations required for creating and verifying alibis can be done on even older Android devices in fractions of a second, and only require a few hundred bytes of storage for each alibi created.&lt;/p&gt;
&lt;h3&gt;Comparison to traditional alibis&lt;/h3&gt;
&lt;p&gt;The alibis in our system have much in common with the types of "traditional alibis" normally found in criminal proceedings.
The strength of a traditional alibi depends on the reliability of the evidence and trustworthiness of the corroborator, and the same applies to our alibis.
Just as in the traditional setting, we cannot prevent alibi owners and corroborators from colluding to create a fake but valid alibi (perjury), so in both cases the evaluation of the strength of the alibi is up to the judge to consider the circumstances and context.&lt;/p&gt;
&lt;p&gt;However, the alibis in our systems have a number of advantages over traditional alibis.
Primarily, the privacy guarantees discussed above allow participants to create alibis without revealing their identity.
Their identity is only revealed to be associated with an alibi if they themselves decide to claim that alibi, which they can do without revealing anything else about other alibis they have created.
Also, our alibis cannot be created without the consent and participation of the alibi owner.&lt;/p&gt;
&lt;p&gt;Furthermore, our alibis have non-forgeability properties beyond that of many traditional alibis, including the ability to reveal one-sided forgeries, where either the alibi owner or corroborator attempts to counterfeit or modify an existing alibi without the other party's explicit, intentional participation.&lt;/p&gt;
&lt;p&gt;The identities of the participants are directly and unambiguously embedded into the alibis, preventing the common problem in traditional alibis where imperfect human observation and faulty human memory can result in inaccurate alibi testimony.&lt;/p&gt;
&lt;p&gt;We have designed our schemes so the alibi owner stores all data necessary to corroborate and verify the alibi, as they have the greatest incentive to do so.
Unlike many traditional alibis, our alibis do not rely on the memory of the corroborator after alibi creation.&lt;/p&gt;
&lt;p&gt;Our papers detail the precise threat model, assumptions, properties and guarantees of our systems, including the safeguards and checks that prevent various types of fraud and perjury.&lt;/p&gt;
&lt;h3&gt;Read more in these publications&lt;/h3&gt;
&lt;p&gt;Parts of this work have been published in the following peer-reviewed publication:&lt;/p&gt;
&lt;p&gt;&lt;span class="bib-entry"&gt;
    &lt;span class="papertitle"&gt;Privacy-Preserving Alibi Systems (&lt;a href="/pubs/davis-asiaccs12-alibis.pdf"&gt;paper&lt;/a&gt;, &lt;a href="/pubs/davis-asiaccs12-alibis-slides.pdf"&gt;slides&lt;/a&gt;)&lt;/span&gt;
    &lt;span class="author"&gt;Benjamin Davis, Hao Chen, and Matthew Franklin.&lt;/span&gt;
    &lt;span class="venue"&gt;7th ACM Symposium on Information, Computer and Communications Security (ASIACCS). Seoul, South Korea, May 1-3, 2012.&lt;/span&gt;
  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;For further elaboration, please see my Ph.D. dissertation:&lt;/p&gt;
&lt;p&gt;&lt;span class="bib-entry"&gt;
    &lt;span class="papertitle"&gt;&lt;a href="/pubs/davis-dissertation.pdf"&gt;Protecting Systems from Within:&lt;br /&gt;Application-Level Observation and Control Mechanisms&lt;/a&gt;&lt;/span&gt;
    &lt;span class="author"&gt;Benjamin Davis, Department of Computer Science, University of California, Davis.&lt;/span&gt;
    &lt;span class="venue"&gt;Dissertation Committee: Hao Chen, Matthew Bishop, Karl Levitt&lt;/span&gt;
  &lt;/span&gt;&lt;/p&gt;</summary><category term="crypto"></category><category term="privacy"></category><category term="mobile"></category></entry><entry><title>DBT: Cross-Application Information Flow Tracking via Databases</title><link href="http://www.thebendavis.net/blog/dbtaint-database-information-flow-tracking-overview/" rel="alternate"></link><published>2015-02-06T20:00:00-05:00</published><author><name>Ben Davis</name></author><id>tag:www.thebendavis.net,2015-02-06:blog/dbtaint-database-information-flow-tracking-overview/</id><summary type="html">&lt;h3&gt;The dangers of user content&lt;/h3&gt;
&lt;p&gt;One major challenge modern web services face is how to safely incorporate user content.
Naive use of potentially malicious content can leave the service and its visitors vulnerable to attack.
Many of these attacks work by &lt;a href="https://en.wikipedia.org/wiki/Code_injection"&gt;code injection&lt;/a&gt;, in which improperly handled content is used in an unsafe way.
For example, in &lt;a href="https://en.wikipedia.org/wiki/Cross-site_scripting"&gt;cross-site scripting (XSS)&lt;/a&gt;, malicious content is injected into web pages served to users of the web service.
This can allow an attacker to bypass the same-origin policy, steal credentials of other users visiting the site, and much more.&lt;/p&gt;
&lt;p&gt;In order to prevent these types of attacks, the developers of a service must make sure that all untrusted (potentially malicious) content is sanitized before it is used in an unsafe way.
Unfortunately, any mistake could leave a gap that an attacker could use to exploit the service.
Trying to find and close all of these gaps, while avoiding the introduction of new ones, can seem like a game of &lt;a href="https://en.wikipedia.org/wiki/Whac-A-Mole#Colloquial_usage" title="whenever a problem is 'whacked,' another one pops up somewhere else"&gt;Whac-A-Mole&lt;/a&gt;, especially in systems originally developed without following industry best practices.&lt;/p&gt;
&lt;h3&gt;Tell me before I do something stupid!&lt;/h3&gt;
&lt;p&gt;Taking a step back, we see that the general problem is that when data is used in a dangerous operation the system has no way to know whether this data is safe to use or not.
It's up to the developers to make sure only safe (sanitized) data makes it this far - and to never make a mistake!
But there is another way to make sure only safe data is used in dangerous operations...&lt;/p&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Information_flow_%28information_theory%29" title="Information flow (information theory)"&gt;Information flow&lt;/a&gt; is a way to reason about how data flows through a system.
&lt;a href="http://en.wikipedia.org/wiki/Taint_checking"&gt;Taint checking&lt;/a&gt; can provide a dynamic system that approximates the verification from full information flow analysis.
In systems that provide taint checking, data from an untrusted source is marked as "tainted" in metadata associated with the data.
While we support more sophisticated schemes, let's simplify the discussion by assuming there is only a single bit of metadata for each data value, indicating either "tainted" or "untainted."
Tainted data can only become untainted by passing through the appropriate sanitization routine, ensuring it is safe for use.&lt;/p&gt;
&lt;p&gt;This metadata accompanies the data itself as it passes through the system, such as from one variable to another.
When data is passed to a potentially dangerous operation (e.g., &lt;code&gt;eval&lt;/code&gt;), this tracking system can inspect the metadata on the data to determine if the value is "tainted."
If so, then the system knows that this is (or at least could be) unsanitized data from an untrusted source and should not be allowed to be used in this dangerous operation.&lt;/p&gt;
&lt;p&gt;There are many dynamic information flow tracking systems that provide taint checking.
Perl and Ruby both include taint modes, and third-party systems exist for other languages, such as &lt;a href="http://www.eecs.berkeley.edu/~daw/papers/taint-sws09.pdf" title="Efficient Character-level Taint Tracking for Java"&gt;Java (PDF link)&lt;/a&gt; and &lt;a href="http://php.net/manual/en/book.taint.php"&gt;PHP&lt;/a&gt;.
This seems perfect for preventing cross-site scripting, SQL-injection, and many other attacks, so why isn't it widely used in web services?&lt;/p&gt;
&lt;h3&gt;Limitations of information flow tracking implementations&lt;/h3&gt;
&lt;p&gt;Unfortunately, most information flow tracking systems only work for a single application at a time.
For example, Perl's taint mode only maintains and propagates this taint metadata on data as it flows through the Perl program.
The problem is that most web services include not only a web application, but also a database.
All the metadata Perl's taint mode tracks is lost when sending data across the application boundaries into the database.
Similarly, when data is retrieved from the database Perl's taint mode has no idea how it should be marked.
The only two options Perl provides for this is to:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;treat everything from the database as tainted, or&lt;/li&gt;
&lt;li&gt;treat everything from the database as untainted&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Obviously, neither will provide satisfactory results for most web services.&lt;/p&gt;
&lt;p&gt;Other single-application information flow tracking systems have the same drawbacks.
And while system-wide information flow tracking systems exist, these generally lack the necessary granularity and support of database semantics to provide the precision necessary to protect against common web attacks.&lt;/p&gt;
&lt;p&gt;What can we do?&lt;/p&gt;
&lt;h3&gt;DBTaint enables cross-application information flow tracking via databases&lt;/h3&gt;
&lt;p&gt;At UC Davis, I led a project with the goal of empowering administrators of web services to use existing single-application information flow tracking systems in multi-application web services.
Since we enable taint checking from applications into databases, through database operations, and back into the application, we named this project &lt;strong&gt;DBTaint&lt;/strong&gt;.
DBTaint was designed and built to meet the following requirements:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;efficient end-to-end taint tracking through applications and databases&lt;/li&gt;
&lt;li&gt;full support of database operations and semantics&lt;/li&gt;
&lt;li&gt;deployment is transparent (requires no changes) to the web application&lt;/li&gt;
&lt;li&gt;requires only SQL-level changes on the database server (uses stock database engine)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Design and implementation&lt;/h3&gt;
&lt;p&gt;On initialization, DBTaint performs SQL-level changes to the database tables used by the app.
Additionally, DBTaint creates composite-type versions of all of the database data types.
These composite types include the data value as well as the associated metadata (i.e., taint value).
Also, it initializes and overloads the necessary database functions in order to perform taint-value propagation through database operations.
For example, it adds a &lt;code&gt;SUM&lt;/code&gt; function that produces an untainted result if and only if all of the values passed to it are untainted, otherwise it returns a result with the highest taint value of all of the input values.
Please see the publications listed below for details on the semantics of the database operations.&lt;/p&gt;
&lt;p&gt;This is a diagram showing a web service running in DBTaint.&lt;/p&gt;
&lt;p&gt;&lt;img alt="DBTaint System Diagram" src="http://www.thebendavis.net/blog_media/2015/dbtaint/dbtaint-system-diagram.png" title="&amp;quot;DBTaint System Diagram&amp;quot; =200x" /&gt;&lt;/p&gt;
&lt;p&gt;In the diagram above, the red rounded rectangle around the Web App indicates the single-application information flow tracking system (e.g., Perl's taint mode).
Observe that when a web app communicates with the database via a standard database interface module, this database interface is still running within the same single-application information flow tracking system.
The metadata associated with data intended for the database has not yet been lost.&lt;/p&gt;
&lt;p&gt;DBTaint provides end-to-end taint tracking transparently to the web application by augmenting the database interface to intercept and automatically rewrite database queries made by the web app.
When inserting data, the DBTaint-augmented version of the interface parses the query at run-time, and rewrites it to include the metadata associated with each data value before sending the rewritten query to the database.
This metadata is stored and propagated through the database using our composite types and functions.
Similarly, when querying for data, our augmented interface will collapse the resulting composite data/metadata pairs it gets from the database into appropriately tainted data values, which it returns to the web application.&lt;/p&gt;
&lt;p&gt;A major benefit of this approach is that the web app makes the same queries (and receives the same results) as running without DBTaint, so these changes are completely transparent to the web app.
The only difference from the web application's perspective is that the values it receives from the database are tainted appropriately (i.e., more precisely than the all-tainted or all-untainted options available without DBTaint).&lt;/p&gt;
&lt;p&gt;Once we have augmented a standard database interface, DBTaint supports any application that uses that standard interface.
In our current implementation we augment the &lt;a href="https://en.wikipedia.org/wiki/Java_Database_Connectivity"&gt;Java Database Connectivity (JDBC)&lt;/a&gt; interface used by Java programs, and the &lt;a href="https://en.wikipedia.org/wiki/Perl_DBI"&gt;Database Interface (DBI) module&lt;/a&gt; used by Perl programs.&lt;/p&gt;
&lt;p&gt;It is a best practice for application developers to use parameterized SQL queries, which makes it easy to determine the taint values of individual data values passed to the database as query parameters.
But when a web app creates queries by string concatenation, DBTaint parses the query string and uses character-level taint data (when available) to determine the most precise taint values of each data element in the query.&lt;/p&gt;
&lt;h3&gt;Using DBTaint for real-world services&lt;/h3&gt;
&lt;p&gt;Our implementation of DBTaint works with services implemented in Perl and Java that use PostgreSQL databases.
We use Perl's &lt;a href="http://perldoc.perl.org/perlsec.html#Taint-mode" title="perlsec: Taint Mode"&gt;taint mode&lt;/a&gt; (modified to act as a passive taint-tracking system) and &lt;a href="http://www.eecs.berkeley.edu/~daw/papers/taint-sws09.pdf" title="Efficient Character-level Taint Tracking for Java"&gt;this character-level taint tracking engine for Java (PDF link)&lt;/a&gt; to perform the appropriate information flow tracking when running two real-world web services in DBTaint:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.bestpractical.com/rt/" title="RT: Request Tracker"&gt;RT (Request Tracker)&lt;/a&gt;: a popular ticket-tracking system implemented in Perl&lt;/li&gt;
&lt;li&gt;&lt;a href="http://jforum.net/" title="jforum: a powerful and robust discussion board system implemented in Java"&gt;jforum&lt;/a&gt;: a powerful discussion board system implemented in Java&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note that these services were not written with DBTaint (or information flow tracking of any kind) in mind, and our approach did not require any code changes to either application.&lt;/p&gt;
&lt;p&gt;The performance impact of DBTaint on these systems was relatively low (less than 10-15% overhead) in our evaluation.
In additional experiments, we show that we can trade portability for performance by implementing the composite-type metadata propagation database functionality in C rather than in SQL to further reduce the overhead of our approach.
Please see our publications for a more detailed discussion of these topics.&lt;/p&gt;
&lt;h3&gt;Read more in these publications&lt;/h3&gt;
&lt;p&gt;Parts of this work have been published in the following peer-reviewed publication:&lt;/p&gt;
&lt;p&gt;&lt;span class="bib-entry"&gt;
    &lt;span class="papertitle"&gt;DBTaint: Cross-Application Information Flow Tracking via Databases (&lt;a href="/pubs/davis-webapps10-dbtaint.pdf"&gt;paper&lt;/a&gt;, &lt;a href="/pubs/davis-webapps10-dbtaint-slides.pdf"&gt;slides&lt;/a&gt;, &lt;a href="/pubs/davis-webapps10-dbtaint-poster.pdf"&gt;poster&lt;/a&gt;)&lt;/span&gt;
    &lt;span class="author"&gt;Benjamin Davis and Hao Chen.&lt;/span&gt;
    &lt;span class="venue"&gt;USENIX Conference on Web Applications (WebApps). Boston, MA, June 23-24, 2010.&lt;/span&gt;
  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;For further elaboration, please see my Ph.D. dissertation:&lt;/p&gt;
&lt;p&gt;&lt;span class="bib-entry"&gt;
    &lt;span class="papertitle"&gt;&lt;a href="/pubs/davis-dissertation.pdf"&gt;Protecting Systems from Within:&lt;br /&gt;Application-Level Observation and Control Mechanisms&lt;/a&gt;&lt;/span&gt;
    &lt;span class="author"&gt;Benjamin Davis, Department of Computer Science, University of California, Davis.&lt;/span&gt;
    &lt;span class="venue"&gt;Dissertation Committee: Hao Chen, Matthew Bishop, Karl Levitt&lt;/span&gt;
  &lt;/span&gt;&lt;/p&gt;</summary><category term="java"></category><category term="perl"></category><category term="sql"></category><category term="postgresql"></category><category term="web"></category></entry><entry><title>RetroSkeleton: Automatic Android App Bytecode Rewriting</title><link href="http://www.thebendavis.net/blog/retroskeleton-android-app-rewriting-overview/" rel="alternate"></link><published>2015-01-30T20:00:00-05:00</published><author><name>Ben Davis</name></author><id>tag:www.thebendavis.net,2015-01-30:blog/retroskeleton-android-app-rewriting-overview/</id><summary type="html">&lt;h3&gt;Do you know what your apps are doing?&lt;/h3&gt;
&lt;p&gt;Android is the &lt;a href="https://developer.android.com/about/index.html"&gt;most popular mobile platform in the world&lt;/a&gt;, and a major reason for this success is the tremendous number of third-party apps available for these devices.
But as amazing as it is to pack these little computers with sensors, fill them with our data, and keep them with us wherever we go, we should consider the risks we take when we run third-party software.
How can we understand and control what third-party apps are doing on our devices?&lt;/p&gt;
&lt;p&gt;Most Android apps never undergo a rigorous manual review and the controls provided by the Android platform (primarily the permission system) are quite limited.
Android's permission system requires app developers to declare all permissions (which you can think of as categories of functionality) their app may use.
In order to install an app, the user must grant unlimited access to all permissions requested by the app.
Many important permissions lack granularity.
For example, the &lt;code&gt;INTERNET&lt;/code&gt; permission enables unlimited connections to any host.
Once the app is installed, the user cannot change, restrict, or revoke the app's ability to perform most sensitive operations.&lt;/p&gt;
&lt;p&gt;These are not hypothetical concerns.
For example, when you install an app, Android does not allow you to
prevent a flashlight app from &lt;a href="http://www.ftc.gov/news-events/press-releases/2013/12/android-flashlight-app-developer-settles-ftc-charges-it-deceived" title="Android Flashlight App Developer Settles FTC Charges It Deceived Consumers: 'Brightest Flashlight' App Shared Users' Location, Device ID Without Consumers' Knowledge"&gt;uploading your personal data and location&lt;/a&gt;,
force &lt;a href="http://android-ssl.org/files/p50-fahl.pdf" title="Why Eve and Mallory Love Android: An Analysis of Android SSL (In)Security"&gt;apps that make insecure HTTP requests&lt;/a&gt; to use (encrypted) HTTPS connections instead,
or apply &lt;a href="http://android-developers.blogspot.ie/2013/08/some-securerandom-thoughts.html" title="Android Developers Blog: Some SecureRandom Thoughts"&gt;workarounds&lt;/a&gt;
to &lt;a href="http://www.symantec.com/connect/blogs/android-cryptographic-issue-may-affect-hundreds-thousands-apps" title="Android Cryptographic Issue May Affect Hundreds of Thousands of Apps"&gt;platform weaknesses&lt;/a&gt;
that leave &lt;a href="https://bitcoin.org/en/alert/2013-08-11-android" title="Android Security Vulnerability"&gt;unpatched bitcoin wallet apps vulnerable&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;RetroSkeleton gives users control over their apps&lt;/h3&gt;
&lt;p&gt;At the University of California, Davis, I led a project where my colleagues and I set out to develop a practical way to give users insight into and control over the third-party apps on their Android devices.
We developed RetroSkeleton: an Android app analysis and bytecode rewriting framework for altering the behavior of existing applications without requiring source code or app-specific guidance.
RetroSkeleton rewrites an app to produce a new app that obeys the desired policy.
The foundation of our system is a sophisticated static analysis engine that determines the modifications needed in order to enforce the desired behavior in an app automatically.
We named this app rewriting system RetroSkeleton after the ability to retrofit apps with new behavior by modifying their internals.&lt;/p&gt;
&lt;p&gt;We designed our system to be:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Complete:&lt;/strong&gt; able to intercept all invocations of behavior of interest, including those invoked dynamically (e.g., via reflection)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Flexible:&lt;/strong&gt; powerful enough to satisfy a wide range of security and functionality goals&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;App-Independent:&lt;/strong&gt; no manual app-specific guidance needed to create or apply these transformation policies&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Deployable:&lt;/strong&gt; rewritten apps work on unrooted, unmodified, stock Android devices with no additional software required&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;How does it work?&lt;/h3&gt;
&lt;p&gt;RetroSkeleton allows policy writers to create a single, high-level, app-agnostic policy that RetroSkeleton can apply to any Android app without requiring any manual guidance.
Our system takes as input an app-agnostic policy and applies it to an app automatically by identifying all the necessary transformations and generating all code needed for handlers/dispatch and interposition.
RetroSkeleton parses and rewrites &lt;a href="https://source.android.com/devices/tech/dalvik/dex-format.html" title="Dalvik Executable format"&gt;Android (dex) bytecode&lt;/a&gt; directly (i.e., rather than converting to Java bytecode), replacing all invocations of methods of interest with calls to new handlers with custom behavior, as determined by a policy specification.
Analysis and rewriting is done statically, but generates and inserts handlers that can make policy decisions within the rewritten app at run-time to deal with reflection and other dynamic behavior.
Rewritten apps can run on stock Android devices (no rooting/custom ROMs required).&lt;/p&gt;
&lt;p&gt;&lt;img alt="RetroSkeleton System Diagram" src="http://www.thebendavis.net/blog_media/2015/retroskeleton/retroskeleton-system-diagram.svg" title="RetroSkeleton System Diagram" /&gt;&lt;/p&gt;
&lt;p&gt;Users may apply RetroSkeleton to apps they download on their own, either directly or via online service, and corporate environments could require that apps be rewritten before installation on company devices (either on-demand or by providing a private market of rewritten apps).
Because RetroSkeleton policy specifications are app-agnostic, a small set of community-maintained and vetted policies could be used by a wide range of users.&lt;/p&gt;
&lt;p&gt;The majority of RetroSkeleton is implemented in &lt;a href="http://clojure.org/"&gt;Clojure&lt;/a&gt; and Java, with earlier work implemented in Python.
Please see our publications for details on the design and implementation of our system, as well as the interface policy writers use for policy specification.&lt;/p&gt;
&lt;h3&gt;Using RetroSkeleton on real apps&lt;/h3&gt;
&lt;p&gt;We created a number of policies to showcase the power and flexibility of RetroSkeleton.
Here are some of the behaviors our policies can automatically embed and enforce in Android apps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;prevent connections to unauthorized hosts via fine-grained network access controls (including user-configurable white/blacklists)&lt;/li&gt;
&lt;li&gt;dynamically replace apps' insecure HTTP requests (a &lt;a href="http://android-ssl.org/files/p50-fahl.pdf" title="Why Eve and Mallory Love Android: An Analysis of Android SSL (In)Security"&gt;common problem&lt;/a&gt;) with encrypted HTTPS requests when available (a la the &lt;a href="https://www.eff.org/https-everywhere" title="HTTPS-Everywhere browser extensions"&gt;HTTPS-Everywhere&lt;/a&gt; extensions for browsers)&lt;/li&gt;
&lt;li&gt;perform (rudimentary) app localization by translating app UI text dynamically via online translation services (think "translate this page" for app UI content)&lt;/li&gt;
&lt;li&gt;automatically patch apps with &lt;a href="http://android-developers.blogspot.ie/2013/08/some-securerandom-thoughts.html" title="Android Developers Blog: Some SecureRandom Thoughts"&gt;workarounds&lt;/a&gt; for &lt;a href="http://www.symantec.com/connect/blogs/android-cryptographic-issue-may-affect-hundreds-thousands-apps" title="Android Cryptographic Issue May Affect Hundreds of Thousands of Apps"&gt;known cryptographic vulnerabilities&lt;/a&gt; in older versions of the Android platform&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We applied each of these policies to over 1,000 top free apps from &lt;a href="https://play.google.com/store"&gt;Google Play&lt;/a&gt; and built an automated test system to run and exercise each rewritten app in an Android emulator to confirm the functionality of the rewritten apps, including the enforcement of the desired behavior.
Nearly all (more than 97.5%) successfully ran after rewriting (a few threw errors as a result of poorly handling changes in behavior, such as expecting a hardcoded string but receiving the translated version of that string).
For more details, please see our publications below.&lt;/p&gt;
&lt;p&gt;For most policies, the impact of the rewriting process on the size and run-time performance of the app is minimal.
On average, rewritten apps increased in size by only a few KiB, which was a less than 0.13% increase in overall app size in our data set.
The specific run-time performance impact depends on the new behavior added, but the inherent overhead of our approach is low, adding only fractions of a microsecond when interposing on method calls of interest (even on aging hardware).
Because much of the work is done statically, generally the impact is not much more than if the developer had originally written the app with the additional behavior.
The static analysis and app rewriting process itself is efficient in terms of time and computation required, averaging about 5 seconds to rewrite an app using normal desktop PC hardware.&lt;/p&gt;
&lt;h3&gt;Read more in these publications&lt;/h3&gt;
&lt;p&gt;Parts of this work have been published in the following peer-reviewed publications:&lt;/p&gt;
&lt;p&gt;&lt;span class="bib-entry"&gt;
    &lt;span class="papertitle"&gt;RetroSkeleton: Retrofitting Android Apps (&lt;a href="/pubs/davis-mobisys13-retroskeleton.pdf"&gt;paper&lt;/a&gt;, &lt;a href="/pubs/davis-mobisys13-retroskeleton-slides.pdf"&gt;slides&lt;/a&gt;)&lt;/span&gt;
    &lt;span class="author"&gt;Benjamin Davis and Hao Chen.&lt;/span&gt;
    &lt;span class="venue"&gt;11th International Conference on Mobile Systems, Applications and Services (MobiSys). Taipei, Taiwan, June 25-28, 2013.&lt;/span&gt;
  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="bib-entry"&gt;
    &lt;span class="papertitle"&gt;I-ARM-Droid: A Rewriting Framework for In-App Reference Monitors for Android Applications (&lt;a href="/pubs/davis-most12-iarm.pdf"&gt;paper&lt;/a&gt;, &lt;a href="/pubs/davis-most12-iarm-slides.pdf"&gt;slides&lt;/a&gt;)&lt;/span&gt;
    &lt;span class="author"&gt;Benjamin Davis, Ben Sanders, Armen Khodaverdian, and Hao Chen.&lt;/span&gt;
    &lt;span class="venue"&gt;IEEE Mobile Security Technologies (MoST). San Francisco, CA, May 24, 2012.&lt;/span&gt;
  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;For further elaboration, please see my Ph.D. dissertation:&lt;/p&gt;
&lt;p&gt;&lt;span class="bib-entry"&gt;
    &lt;span class="papertitle"&gt;&lt;a href="/pubs/davis-dissertation.pdf"&gt;Protecting Systems from Within:&lt;br /&gt;Application-Level Observation and Control Mechanisms&lt;/a&gt;&lt;/span&gt;
    &lt;span class="author"&gt;Benjamin Davis, Department of Computer Science, University of California, Davis.&lt;/span&gt;
    &lt;span class="venue"&gt;Dissertation Committee: Hao Chen, Matthew Bishop, Karl Levitt&lt;/span&gt;
  &lt;/span&gt;&lt;/p&gt;</summary><category term="android"></category><category term="dalvik"></category><category term="mobile"></category></entry></feed>